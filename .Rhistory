##converted to numeric variable
Block <- as.numeric(BlockOrig)
##other info
nsites <- nrow(car)
nvisits <- ncol(car)
nblocks <- length(unique(Block))
ngroups <- length(unique(Coupe))
modelstring <- "
model {
##prior
#prior for psi
for(k in 1:ngroups) {
psi[k] ~ dunif(0, 1)
}
#prior for p
alpha0.car ~ dnorm(0, 0.01)
alpha.precip.car ~ dnorm(0, 0.01)
alpha.cwd.car ~ dnorm(0, 0.01)
##random effects of block
for(m in 1:nblocks) {
alpha.block[m] ~ dnorm(0, tau.block)
}
tau.block <- pow(sigma.block, -2)
sigma.block ~ dunif(0, 10)
##likelihood
##first loop over nsites
for (i in 1:nsites) {
##True occupancy z at site i (biological process)
z[i] ~ dbern(psi[Group[i]])
##linear predictor of psi
#logit.psi[i] <- beta0.car + beta.litter.car * Litter[i]
#psi[i] <- exp(logit.psi[i])/(1 + exp(logit.psi[i]))
##second loop over nvisits
for (j in 1:nvisits) {
##linear predictor of p
logit.p[i, j] <- alpha0.car + alpha.cwd.car * CWD[i] + alpha.precip.car * Precip[i, j] + alpha.block[Block[i]]
p[i, j] <- exp(logit.p[i, j])/(1 + exp(logit.p[i, j]))
##p = 0 if site not occupied
eff.p[i, j] <- z[i] * p[i, j]
##detection at i j (observation process)
y[i, j] ~ dbern(eff.p[i, j])
}
}
## derived parameter
##number of occupied sites among nsites
finiteOcc <- sum(z[])
}
"
## named list
linData.car <- list(y = as.matrix(car),
nsites = nsites,
nvisits = nvisits,
ngroups = ngroups,
CWD = CWD,
Precip = as.matrix(Precip),
Group = ifelse(Coupe == "temoin", 1,
ifelse(Coupe == "partielle", 2,
3)),
Block = Block, nblocks = 4)
## remove dimension names
dimnames(linData.car$y) <- NULL
dimnames(linData.car$Precip) <- NULL
str(linData.car)
## use known occupied values
zstart <- apply(car, 1, max)
zstart
## function to assign initial values at each iteration
inits <- function(){
list(z = zstart,
psi = runif(ngroups, 0, 1),
alpha0.car = rnorm(1),
alpha.precip.car = rnorm(1),
alpha.cwd.car = rnorm(1),
alpha.block = rnorm(nblocks),
sigma.block = runif(1, 0, 10))
}
## vector of names
params <- c("psi",
"alpha0.car",
"alpha.precip.car",
"alpha.cwd.car",
"alpha.block", "sigma.block",
"finiteOcc")
## MCMC settings
## chains
nc <- 5
## iterations
ni <- 200000
## burn-in
nb <- 150000
## thinning rate (save 1 obs per 5 iterations)
nt <-10
library(jagsUI)
out.occ.car <- jags(data = linData.car,
inits = inits,
parameters = params,
model = "occ.car-psiCutpCWDPrecBlock.jags",
n.thin = nt,
n.chains = nc,
n.burnin = nb,
n.iter = ni,
n.adapt = 10000)
## out.occ.car competitor
save(out.occ.car, file = "out.occ.car.comp-PsiCut-PCWDPrecBlock-200K150Kb.Rdata")
## out.occ.car prey
# save(out.occ.car, file = "out.occ.car.prey-PsiCut-PCWDPrecBlock-200K150Kb.Rdata")
load("out.occ.car.prey-PsiCut-PCWDPrecBlock-200K150Kb.Rdata")
outSumcar <- out.occ.car$summary [,c("mean", "sd", "2.5%", "97.5%", "Rhat")]
round(outSumcar, 4)
##trace plots
jagsUI:::traceplot(out.occ.car, parameters = c("psi"))
##to view some diagnostics
library(mcmcplots)
mcmcplot(out.occ.pcin$samples)
##to view some diagnostics
library(mcmcplots)
mcmcplot(out.occ.car$samples)
##trace plots
jagsUI:::traceplot(out.occ.car, parameters = c("psi"))
jagsUI:::traceplot(out.occ.car, parameters = c("alpha0.car",
"alpha.precip.car",
"alpha.cwd.car"))
jagsUI:::traceplot(out.occ.car, parameters = c("alpha.block", "sigma.block"))
##posterior density plots
par(mfrow = c(1, 1))
plot(density(out.occ.car$sims.list$psi[, 1]),
main = "psi[1]")
plot(density(out.occ.car$sims.list$psi[, 2]),
main = "psi[2]")
plot(density(out.occ.car$sims.list$psi[, 3]),
main = "psi[4]")
plot(density(out.occ.car$sims.list$alpha0.car),
main = "alpha0.car")
plot(density(out.occ.car$sims.list$alpha.precip.car),
main = "alpha.precip.car")
plot(density(out.occ.car$sims.list$alpha.cwd.car),
main = "alpha.cwd.car")
plot(density(out.occ.car$sims.list$sigma.block),
main = "sigma.block")
plot(density(out.occ.car$sims.list$alpha.block[, 1]),
main = "alpha.block[1]")
plot(density(out.occ.car$sims.list$alpha.block[, 2]),
main = "alpha.block[2]")
plot(density(out.occ.car$sims.list$alpha.block[, 3]),
main = "alpha.block[3]")
plot(density(out.occ.car$sims.list$alpha.block[, 4]),
main = "alpha.block[4]")
library(coda)
coda.out.car <- summary(out.occ.car$samples)
##MC error across all parameters
Ratio.car <- coda.out.car$statistics[, "Time-series SE"]/coda.out.car$statistics[, "SD"]
Ratio.car
any(Ratio.car > 0.05)
##difference between groups
diff.1v2.car <- out.occ.car$sims.list$psi[, 1] -
out.occ.car$sims.list$psi[, 2]
hist(diff.1v2.car)
quant1v2.car <- quantile(diff.1v2.car, probs = c(0.025, 0.975))
abline(
v = quant1v2.car,
lty = 2,
col = "red",
lwd = 3
)
quant1v2.car
diff.1v3.car <- out.occ.car$sims.list$psi[, 1] -
out.occ.car$sims.list$psi[, 3]
hist(diff.1v3.car)
quant1v3.car <- quantile(diff.1v3.car, probs = c(0.025, 0.975))
abline(
v = quant1v3.car,
lty = 2,
col = "red",
lwd = 3
)
quant1v3.car
diff.2v3.car <- out.occ.car$sims.list$psi[, 2] -
out.occ.car$sims.list$psi[, 3]
hist(diff.2v3.car)
quant2v3.car <- quantile(diff.2v3.car, probs = c(0.025, 0.975))
abline(
v = quant2v3.car,
lty = 2,
col = "red",
lwd = 3
)
quant1v3.car
outSum.car <-
out.occ.car$summary [, c("mean", "sd", "2.5%", "97.5%", "Rhat")]
# par(mar = c(5.1, 4.1, 4.1, 2.1))  # Adjust margin
par(mfcol = c(1, 1))
par(mar = c(5.1, 5.1, 4.1, 4.1))  # Adjust margin
# essaie sample data
occ_data <- data.frame(
treatments = c("Témoin", "Partielle", "Totale"),
mean = c(outSum.car[1:3, 1]),
lower = c(outSum.car[1:3, 3]),
upper = c(outSum.car[1:3, 4])
)
# Create a  plot
plot(
NA,
xlim = c(0, 4),
ylim = c(0, 1),
main = paste0("Carabes du groupe \"proie de salamandres\""),
xlab = "Coupes forestières",
ylab = "Probabilité d'occupation",
xaxt = "n",
cex.axis = 1,
cex.lab = 1)
# Add lines for each treatment
segments(
x0 = 1:3,
y0 = occ_data$lower,
1:3,
occ_data$upper,
col = "black",
lwd = 2
)
# Add points for mean occupation probabilities
points(
x = 1:3,
y = occ_data$mean,
pch = 19,
col = "black",
lwd = 2
)
axis(1, at = 1:3, labels = occ_data$treatments, lwd = 1, padj = 1)
#positionnement
setwd(dir = "/Users/williamdevos/Documents/Maitrise/Data")
#positionnement
setwd(dir = "/Users/williamdevos/Documents/Maitrise/Data.Git")
# importation du jeu de données
load("SEM_data_JAGS.RData")
hist(data.JAGS$coll$weight)
identical(data.JAGS$coll$site, data.JAGS$Obs_cov$ID)
View(data.JAGS)
identical(data.JAGS$coll$site, data.JAGS$Obs_cov$sites)
paste(data.JAGS$coll$sites, "--", data.JAGS$Obs_cov$sites)
##collembola biomass
Biomasse <- data.JAGS$coll$weight
##cutting treatment
Coupe <- data.JAGS$Obs_cov$Coupe
##numeric ID to select groups
CoupeNum <- as.numeric(data.JAGS$Obs_cov$Coupe)
BlockOrig <- data.JAGS$Obs_cov$Bloc
##converted to numeric variable
Block <- as.numeric(BlockOrig)
# transform cutting treatment in binary
Cutcontrol<- ifelse(Coupe == "temoin", 1, 0)
Cutpartial<- ifelse(Coupe == "partielle", 1, 0)
Cutclear<- ifelse(Coupe == "totale", 1, 0)
# nsites
nsites <- length(Biomasse)
nblocks <- length(unique(Block))
## model biomass ~ dnorm()
modelstring <- "
model {
## Priors
beta0 ~ dnorm(0, 0.01)
beta.Cutpartial ~ dnorm(0, 0.01)
beta.Cutclear ~ dnorm(0, 0.01)
##random effects of block
for(m in 1:nblocks) {
alpha.block[m] ~ dnorm(0, tau.block)
}
tau.block <- pow(sigma.block, -2)
sigma.block ~ dunif(0, 10)
##different variance for each group
for(j in 1:3) {
tau[j] <- pow(sigma[j], -2)
sigma[j] ~ dunif(0, 150)
}
## Likelihood
for (i in 1:nsites) {
mu[i] <- beta0 + beta.Cutpartial*Cutpartial[i] + beta.Cutclear*Cutclear[i] + alpha.block[Block[i]]
Biomasse[i] ~ dnorm(mu[i], tau[CoupeNum[i]])
}
##predicted values
for(i in 1:nsites) {
pred[i] <- mu[i]
##raw residuals
res[i] <- Biomasse[i] - mu[i]
##Pearson residuals
res.pearson[i] <- res[i]/sigma[CoupeNum[i]]
}
}
"
writeLines(modelstring, con = "Coll_BioMasse_Cut-hetVar-block.jags")
## list of data
lin.data <- list(
Biomasse = as.numeric(Biomasse),
Cutpartial = as.numeric(Cutpartial),
Cutclear = as.numeric(Cutclear),
CoupeNum = CoupeNum,
nsites = nsites,
Block = Block, nblocks = 4
)
View(data.JAGS)
str(lin.data)
# initial values of intercepts
inits <- function( ){
list(beta0 = rnorm(1),
beta.Cutpartial = rnorm(1),
beta.Cutclear = rnorm(1),
sigma = rlnorm(3),
alpha.block = rnorm(nblocks),
sigma.block = runif(1, 0, 10))
}
# output
params <- c("beta0",
"beta.Cutpartial",
"beta.Cutclear",
"sigma",
"pred", "res", "res.pearson", "sigma.block")
## MCMC settings
## chains
nc <- 5
## iterations
ni <- 100000
## burn-in
nb <- 50000
## thinning rate (save 1 obs per 5 iterations)
nt <- 5
library(jagsUI)
out.coll <- jags(data = lin.data,
inits = inits,
parameters = params,
model = "Coll_BioMasse_Cut-hetVar-block.jags",
n.thin = nt,
n.chains = nc,
n.burnin = nb,
n.iter = ni,
n.adapt = 10000)
source("~/Documents/Maitrise/Data.Git/JAGS_coll_Block.RE.R", echo=TRUE)
out.coll$summary[c("beta0",
"beta.Cutpartial",
"beta.Cutclear",
"sigma[1]", "sigma[2]", "sigma[3]"),
c("mean", "sd", "2.5%", "97.5%", "Rhat")]
save(out.coll, file = "out_coll_100K50Kb_BMxCut_hetVar_blockRE.Rdata")
)
out.coll$summary[c("beta0",
"beta.Cutpartial",
"beta.Cutclear",
"sigma[1]", "sigma[2]", "sigma[3]"),
c("mean", "sd", "2.5%", "97.5%", "Rhat")]
##Rhat
hist(out.coll$summary[, "Rhat"])
any(out.coll$summary[, "Rhat"] > 1.1)
par(mfrow = c(2, 3),
mar = c(4, 4, 2, 2))
matplot(cbind(out.coll$samples[[1]][, "beta0"],
out.coll$samples[[2]][, "beta0"],
out.coll$samples[[3]][, "beta0"],
out.coll$samples[[4]][, "beta0"],
out.coll$samples[[5]][, "beta0"]),
type = "l",
ylab = "beta0", xlab = "iteration", cex.lab = 1.2)
par(mfrow = c(2, 3),
mar = c(4, 4, 2, 2))
matplot(cbind(out.coll$samples[[1]][, "beta0"],
out.coll$samples[[2]][, "beta0"],
out.coll$samples[[3]][, "beta0"],
out.coll$samples[[4]][, "beta0"],
out.coll$samples[[5]][, "beta0"]),
type = "l",
ylab = "beta0", xlab = "iteration", cex.lab = 1.2)
matplot(cbind(out.coll$samples[[1]][, "beta.Cutpartial"],
out.coll$samples[[2]][, "beta.Cutpartial"],
out.coll$samples[[3]][, "beta.Cutpartial"],
out.coll$samples[[4]][, "beta.Cutpartial"],
out.coll$samples[[5]][, "beta.Cutpartial"]),
type = "l",
ylab = "beta.Cutpartial", xlab = "iteration", cex.lab = 1.2)
matplot(cbind(out.coll$samples[[1]][, "beta.Cutclear"],
out.coll$samples[[2]][, "beta.Cutclear"],
out.coll$samples[[3]][, "beta.Cutclear"],
out.coll$samples[[4]][, "beta.Cutclear"],
out.coll$samples[[5]][, "beta.Cutclear"]),
type = "l",
ylab = "beta.Cutclear", xlab = "iteration", cex.lab = 1.2)
matplot(cbind(out.coll$samples[[1]][, "sigma[1]"],
out.coll$samples[[2]][, "sigma[1]"],
out.coll$samples[[3]][, "sigma[1]"],
out.coll$samples[[4]][, "sigma[1]"],
out.coll$samples[[5]][, "sigma[1]"]),
type = "l",
ylab = "sigma[1]", xlab = "iteration", cex.lab = 1.2)
matplot(cbind(out.coll$samples[[1]][, "sigma[2]"],
out.coll$samples[[2]][, "sigma[2]"],
out.coll$samples[[3]][, "sigma[2]"],
out.coll$samples[[4]][, "sigma[2]"],
out.coll$samples[[5]][, "sigma[2]"]),
type = "l",
ylab = "sigma[2]", xlab = "iteration", cex.lab = 1.2)
matplot(cbind(out.coll$samples[[1]][, "sigma[3]"],
out.coll$samples[[2]][, "sigma[3]"],
out.coll$samples[[3]][, "sigma[3]"],
out.coll$samples[[4]][, "sigma[3]"],
out.coll$samples[[5]][, "sigma[3]"]),
type = "l",
ylab = "sigma[3]", xlab = "iteration", cex.lab = 1.2)
##to view some diagnostics
library(mcmcplots)
##to view some diagnostics
library(mcmcplots)
mcmcplot(out.coll$samples)
##trace plots
jagsUI:::traceplot(out.coll, parameters = c("psi"))
##trace plots
jagsUI:::traceplot(out.coll, parameters = c("beta0","beta.Cutpartial",
"beta.Cutclear"))
jagsUI:::traceplot(out.coll, parameters = c("sigma[1]","sigma[2]","sigma[3]"))
##using coda package for additional diagnostics
library(coda)
##convert to mcmc.list( ) for coda
outmc <- mcmc.list(out.coll$samples[[1]],
out.coll$samples[[2]],
out.coll$samples[[3]],
out.coll$samples[[4]],
out.coll$samples[[5]])
##save summary in object
coda.out <- summary(outmc)
range(coda.out$statistics[, "Time-series SE"]/coda.out$statistics[, "SD"])
par(mfcol = c(1, 1),
mar = c(5.1, 5.1, 4.1, 4.1))
par(mfcol = c(1, 1),
mar = c(5.1, 5.1, 4.1, 4.1))
diff.1v2.coll <- out.coll$sims.list$beta0 -
out.coll$sims.list$beta.Cutpartial
hist(diff.1v2.coll, main = "Différence des distributions de postérieurs, \npour la probabilité d'occupation des collemboles",
xlab = "Témoin vs coupe partielle",
ylab = "Fréquence"
)
quant1v2.coll <- quantile(diff.1v2.coll, probs = c(0.025, 0.975))
abline(
v = quant1v2.coll,
lty = 2,
col = "red",
lwd = 3
)
quant1v2.coll
diff.1v3.coll <- out.coll$sims.list$beta0 -
out.coll$sims.list$beta.Cutclear
hist(diff.1v3.coll, main = "Différence des distributions de postérieurs, \npour la probabilité d'occupation des collemboles",
xlab = "Témoin vs coupe totale",
ylab = "Fréquence")
quant1v3.coll <- quantile(diff.1v3.coll, probs = c(0.025, 0.975))
abline(
v = quant1v3.coll,
lty = 2,
col = "red",
lwd = 3
)
quant1v3.coll
diff.2v3.coll <- out.coll$sims.list$beta.Cutpartial -
out.coll$sims.list$beta.Cutclear
hist(diff.2v3.coll, main = "Différence des distributions de postérieurs, \npour la probabilité d'occupation des collemboles",
xlab = "Coupe partielle vs coupe totale",
ylab = "Fréquence")
quant2v3.coll <- quantile(diff.2v3.coll, probs = c(0.025, 0.975))
abline(
v = quant2v3.coll,
lty = 2,
col = "red",
lwd = 3
)
quant2v3.coll
outSum.coll <-
out.coll$summary [, c("mean", "sd", "2.5%", "97.5%", "Rhat")]
outSum.coll
# sample data
coll_data <- data.frame(
treatments = c("Témoin", "Coupe partielle", "Coupe totale"),
mean = c(outSum.coll[1:3, 1]),
lower = c(outSum.coll[1:3, 3]),
upper = c(outSum.coll[1:3, 4])
)
coll_data
par(mfcol = c(1, 1),
mar = c(5.1, 5.1, 4.1, 4.1))
# Create a  plot
plot(
NA,
xlim = c(0, 4),
ylim = c(0, 40),
main = "Collemboles",
xlab = "Coupes forestières",
ylab = expression(paste("Biomasse (", mu, "g)")),
xaxt = "n",
cex.axis = 1.2,
cex.lab = 1.2,
cex.main = 1.5)
# Add lines for each treatment
segments(
x0 = 1:3,
y0 = coll_data$lower,
1:3,
coll_data$upper,
col = "black",
lwd = 2
)
# Add points for mean occupation probabilities
points(
x = 1:3,
y = coll_data$mean,
pch = 19,
col = "black",
lwd = 4
)
axis(1, at = 1:3, labels = coll_data$treatments, lwd = 1, padj = 0.5)
